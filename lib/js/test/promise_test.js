// Generated by BUCKLESCRIPT VERSION 1.9.0, PLEASE EDIT WITH CARE
'use strict';

var Tape    = require("bs-sentia-tape/lib/js/src/tape.js");
var Curry   = require("bs-platform/lib/js/curry.js");
var Promise = require("../src/promise.js");

Tape.test("resolve should return a resolved promise", (function (t) {
        Curry._1(t[/* plan */0], 1);
        return Promise.$$finally((function () {
                      return /* () */0;
                    }), (function (x) {
                      return Curry._2(t[/* ok */1], /* None */0, +(x === 5));
                    }), Promise.resolve(5));
      }));

Tape.test("reject should return a rejected promise", (function (t) {
        Curry._1(t[/* plan */0], 1);
        return Promise.$$finally((function (x) {
                      return Curry._2(t[/* ok */1], /* None */0, +(x === "rejected"));
                    }), (function () {
                      return /* () */0;
                    }), Promise.reject("rejected"));
      }));

Tape.test("map should map the resolved value", (function (t) {
        Curry._1(t[/* plan */0], 1);
        return Promise.$$finally((function () {
                      return /* () */0;
                    }), (function (x) {
                      return Curry._2(t[/* ok */1], /* None */0, +(x === 2));
                    }), Promise.map((function (x) {
                          return x + 1 | 0;
                        }), Promise.resolve(1)));
      }));

Tape.test("chain should chain the resolved value", (function (t) {
        Curry._1(t[/* plan */0], 1);
        return Promise.$$finally((function () {
                      return /* () */0;
                    }), (function (x) {
                      return Curry._2(t[/* ok */1], /* None */0, +(x === 2));
                    }), Promise.chain((function (x) {
                          return Promise.resolve(x + 1 | 0);
                        }), Promise.resolve(1)));
      }));

Tape.test("fold should map a resolved promise over the second function", (function (t) {
        Curry._1(t[/* plan */0], 1);
        return Promise.$$finally((function () {
                      return /* () */0;
                    }), (function (n) {
                      return Curry._2(t[/* ok */1], /* None */0, +(n === 2));
                    }), Promise.fold((function (a) {
                          return a;
                        }), (function (n) {
                          return n + 1 | 0;
                        }), Promise.resolve(1)));
      }));

Tape.test("fold should return a resolved promise from a rejected promise", (function (t) {
        Curry._1(t[/* plan */0], 1);
        return Promise.$$finally((function () {
                      return /* () */0;
                    }), (function (x) {
                      return Curry._2(t[/* ok */1], /* None */0, +(x === "Success"));
                    }), Promise.fold((function () {
                          return "Success";
                        }), (function (a) {
                          return a;
                        }), Promise.reject("Err")));
      }));

Tape.test("make should create a new Promise", (function (t) {
        Curry._1(t[/* plan */0], 1);
        return Promise.$$finally((function () {
                      return /* () */0;
                    }), (function (x) {
                      return Curry._2(t[/* ok */1], /* Some */["Promise should be 5"], +(x === 5));
                    }), Promise.make((function (_, resolve) {
                          return Curry._1(resolve, 5);
                        })));
      }));

/*  Not a pure module */
